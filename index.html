<!DOCTYPE html>
<html>

<head>
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no"/>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8"/>
    <title>Leaflet</title>
    <link rel="stylesheet" type="text/css" href="//code.jquery.com/ui/1.9.2/themes/base/jquery-ui.css"/>
    <link rel="stylesheet" type="text/css" href="//cdn.leafletjs.com/leaflet-0.7/leaflet.css"/>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.5.1/dist/leaflet.css"
          integrity="sha512-xwE/Az9zrjBIphAcBb3F6JVqxf46+CDLwfLMHloNu6KEQCAWi6HcDUbeOfBIptF7tcCzusKFjFw2yuvEpDL9wQ=="
          crossorigin=""/>
    <style>
        html,
        body {
            width: 100%;
            height: 100%;
        }

        body {
            padding: 0;
            margin: 0;
        }

        .legend {
            line-height: 18px;
            color: #555;
            background-color: #ffffff;
            border-style: solid;
            border-color: black;
            border-width: 1px;
        }

        .legend i {
            width: 18px;
            height: 18px;
            float: left;
            margin-right: 8px;
            opacity: 1;
        }


        #time-ranges {
            position: fixed;
            top: 43px;
            left: 50%;
            margin-right: -50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
            padding: 1em;
            background: white;
            font-family: Helvetica Neue, Arial, Helvetica, sans-serif;
        }

        #time-ranges input {
            display: inline-block;
            border: 1px solid #999;
            font-size: 14px;
            border-radius: 4px;
            height: 28px;
            line-height: 28px;
        }

        #time-ranges input[type='submit'] {
            box-sizing: content-box;
            padding: 0 1em;
            text-transform: uppercase;
            color: white;
            background: #5C7DB8;
            border-color: #5C7DB8;
        }

        #to select {
            padding: 0 1em;
        }

        #to {
            font-size: 14px;
            height: 30px;
            padding: 0 1em;
            text-transform: uppercase;
        }

        #map_canvas {
            width: 100%;
            height: 100%;
        }
    </style>
    <script src="https://code.jquery.com/jquery-3.3.1.min.js"
            integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous">
    </script>
    <script src="http://code.jquery.com/ui/1.12.0/jquery-ui.js"
            integrity="sha256-0YPKAwZP7Mp3ALMRVB2i8GXeEndvCq3eSl/WsAl1Ryk=" crossorigin="anonymous"></script>

</head>


<body onload="initialize()">
<div id="map_canvas"></div>
<div id="time-ranges" class="leaflet-bar">
    <form action="#" id="form">
        <label for="from">
            From
            <input id="from" type="date" value="2020-01-17" name="from" min="2018-07-07">
        </label>
        <label for="to">
            <label>Period
                <select id="to" name="top5">
                    <option value="1">1 Day</option>
                    <option value="2">2 Days</option>
                    <option>3 Days</option>
                    <option>4 Days</option>
                    <option>5 Days</option>
                </select>
            </label>
        </label>
        <input type="submit" value="Update">
    </form>
</div>
<script src="https://unpkg.com/d3-delaunay@5.1.6/dist/d3-delaunay.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.6.0/proj4-src.js"></script>
<!--<script src="dist/greiner-hormann.js"></script>-->
<script src="polybool.js"></script>
<script src="martinez.umd.js"></script>
<script src="helper.js"></script>
<!--<script type='text/javascript' src="./proj4leaflet.js"></script>-->
<script src="https://unpkg.com/leaflet@1.5.1/dist/leaflet.js"
        integrity="sha512-GffPMF3RvMeYyc1LWMHtK8EbPv0iNZ8/oTtHPx9/cc2ILxQ+u905qIwdpULaqDkyBKgOaB57QTMg7ztg8Jm2Og=="
        crossorigin=""></script>
<script src="leaflet.rotatedMarker.js"></script>
<!--<link rel="stylesheet" href="dist/wind-js-leaflet.css"/>-->
<link rel="stylesheet" href="demo/demo.css"/>
<!--<script src="/dist/wind-js-leaflet.js"></script>-->
<script src="SliderControl.js"></script>
<script>
    let timeForm = document.getElementById('form');
    let dateInput = document.getElementById('from');
    let periodInput = document.getElementById('to');
    from.max = new Date().toISOString().split("T")[0];
    timeForm.addEventListener('submit', function updateTimeRange(e) {
        let date = new Date(dateInput.value);
        let period = periodInput.value;
        console.log(date);
        console.log(period);
        setupWindApi(layerControl, date)
        getDustSensorsByDate(date.year, date.month, date.day);
        e.preventDefault();
    });


    const geocodeUrl = 'https://nominatim.openstreetmap.org/search?q=';
    const geocodeParams = '&format=json&limit=1';
    let map = null;

    let windIcon = L.icon({
        iconUrl: 'images/wind.png',
        iconSize: [100, 100], // size of the icon
        iconAnchor: [0, 32],
        popupAnchor: [0, -32]
    });

    let dustsensors;
    let layerControl;

    async function getDustSensorsByDate(year, month, day) {
        // http://localhost:3000/dust/all/2018-7-7
        // will need a converter from live data to regular data
        return $.getJSON('http://localhost:3000/dust/all/' + year + "-" + month + "-" + day, function (data) {
            console.log("received json");
            // return data;
        });

    }

    function getPoints(sensors) {
        // this returns the coordinates in a linear array
        let points = [];
        for (let i = 0; i < sensors.length; i++) {
            points.push(sensors[i].lon);
            points.push(sensors[i].lat);
        }
        return points
    }

    function filterWantedSensors(dustSensors, hour, minute, bounds, reverseStuttgartPolygon, p2) {
        // dust sensors are all sensors with all measurements from 1 day
        // this returns an array of sensors with values for the requested time only
        let necessarySensors = [];
        for (let key in dustSensors) {
            try {
                let entry = {};
                let sensor = dustSensors[key][hour][minute];
                entry.lon = parseFloat(sensor.lon);
                entry.lat = parseFloat(sensor.lat);

                // e.g. 10.1.2020 ids: 3651=2730 are duplicates
                if ((isDuplicate(necessarySensors, entry)) ||
                    (isOutsidePolygon(entry, reverseStuttgartPolygon))) {
                    continue;
                }

                entry.dust = (p2) ? sensor.p2 : sensor.p1;
                entry.id = key;
                necessarySensors.push(entry);
            } catch (e) {
                // console.log(e);
                console.log("no value for id: " + key + " hour: " + hour + " minute: " + minute);
            }
        }
        addCells(necessarySensors, bounds, reverseStuttgartPolygon);
        return necessarySensors;
    }

    function addCells(wantedSensors, bounds, stuttgartCutoutPolygon) {
        // this calculates the cell surrounding the center by intersection with the Stuttgart polygon
        let delaunay = new d3.Delaunay(getPoints(wantedSensors));

        let voronoi = delaunay.voronoi(bounds);

        let cells = voronoi.cellPolygons();
        let i = 0;
        for (let cell of cells) {
            wantedSensors[i].cell = intersection(cell, stuttgartCutoutPolygon);
            i++;
        }
    }

    async function drawVoronoi(dustSensorPromise, hour, minute, reverseStuttgartPolygon, voronoiLayer, centerLayer, p2) {
        let dustSensors = await dustSensorPromise;

        let bounds = [9.036, 48.68972, 9.3164, 48.8697];

        let wantedSensors = filterWantedSensors(dustSensors, hour, minute, bounds, reverseStuttgartPolygon, p2);

        for (let i = 0; i < wantedSensors.length; i++) {
            let sensor = wantedSensors[i];
            let cell = sensor.cell;
            if ((cell !== undefined) && (cell !== null)) {
                let polygon = L.polygon(cell, {
                    fillColor: getColor(sensor.dust),
                    color: "#222222",
                    weight: 2,
                    fillOpacity: 0.6
                });
                polygon.bindPopup("Polygon #" + sensor.id + " (" + sensor.lat + "," + sensor.lon + ") dust: " + sensor.dust);
                polygon.addTo(voronoiLayer);
            } else {
                console.log("No polygon for sensor, possibly out of area");
                console.log(sensor)
            }
            let center = L.rectangle([[sensor.lat, sensor.lon], [sensor.lat, sensor.lon]], {
                color: "#222222",
                weight: 3
            });
            center.bindPopup("Sensor #" + sensor.id + " (" + sensor.lat + "," + sensor.lon + ") dust: " + sensor.dust);
            center.addTo(centerLayer);
        }
    }

    async function getStuttgartPolygons() {
        let converter = getCoordConverter();
        let stuttgartGeoJSON = await $.getJSON('http://localhost:3000/landkreis');
        let coordinates = stuttgartGeoJSON.features[0].geometry.coordinates[0]; // coordinates are nested arrays, there is only a single polygon
        for (let i = 0; i < coordinates.length; i++) {
            let point = coordinates[i];
            coordinates[i] = converter.inverse(point);
        }

        let worldShadow = [
            [180, -90],
            [180, 90],
            [-180, 90],
            [-180, -90]];

        stuttgartGeoJSON.features[0].geometry.coordinates[0] = coordinates;

        // adds large polygon before stuttgart to make it a cutout
        stuttgartGeoJSON.features[0].geometry.coordinates.unshift(worldShadow);
        return stuttgartGeoJSON;
    }

    function addLayer(stuttgartGeoJSON, stuttgart) {
        L.geoJSON(stuttgartGeoJSON.features, {
            style: {
                "color": "#222222",
                "weight": 5,
                "fillOpacity": 0.5
            }
        }).addTo(stuttgart);
    }

    function initialize() {
        var Esri_WorldImagery = L.tileLayer(
            "http://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
            {
                attribution:
                    "Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, " +
                    "AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community",
                minZoom: 12
            }
        );


        let center = L.latLng(48.8, 9.2);
        let zoom = 11;
        map = L.map('map_canvas').setView(center, zoom);
        let osm = new L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'Map data Â© <a href="https://openstreetmap.org">OpenStreetMap</a> contributors',
            minZoom: 12,
            maxZoom: 2,
            renderer: L.svg(),
        });
        map.addLayer(Esri_WorldImagery);

        dustsensors = L.layerGroup().addTo(map);
        let voronoiLayer = L.layerGroup().addTo(map);
        let centerLayer = L.layerGroup();
        let stuttgartLayer = L.layerGroup().addTo(map);

        getStuttgartPolygons().then((stuttgartGeoJSON) => {
            addLayer(stuttgartGeoJSON, stuttgartLayer);
            // start slider here
            let year = 2020;
            let month = 1;
            let day = 1;
            let hour = 15;
            let minute = 50;
            let dustSensorsPromise = getDustSensorsByDate(year, month, day);
            drawVoronoi(dustSensorsPromise, hour, minute, stuttgartGeoJSON.features[0].geometry.coordinates[1], voronoiLayer, centerLayer);
        });

        let background = {Satellite: Esri_WorldImagery, "Clear map": osm};
        let foreground = {
            "Feinstaubsensoren": dustsensors,
            "Voronoi": voronoiLayer,
            "Centers": centerLayer,
        };
        let layerControl = L.control.layers(background, foreground, {collapsed: false}).addTo(map);

        let timestamp = new Time(8, 20);
        console.log(timestamp);

        //pastData(layerControl, timestamp);
        // currentData(layerControl)
        // setInterval(function () {
        //     currentData(layerControl)
        // }, 300000)
        setupWindApi(layerControl, null)
    }

    function Time(hour, minute, second) {
        this.hour = hour;
        this.minute = minute;
    }

    function addSlider(sensors) {
        console.log(dustsensors);
        var marker1 = L.marker([51.5, -0.09], {time: "2013-01-22 08:42:26+01"});
        var marker2 = L.marker([51.6, -0.09], {time: "2013-01-22 10:00:26+01"});
        var marker3 = L.marker([51.7, -0.09], {time: "2013-01-22 10:03:29+01"});
        layer = L.layerGroup([dustsensors, marker1, marker2])
        //initiate slider, follow = 1 means, show one feature at a time
        sliderControl = L.control.sliderControl({position: "topright", layer: layer, follow: true});
        map.addControl(sliderControl);//add slider to map
        sliderControl.startSlider();
    }

    async function getDustSensorsByDate(year, month, day) {
        // $.getJSON('http://localhost:3000/dust/all/2018-7-7', function (data) {
        return $.getJSON('http://localhost:3000/dust/all/' + year + "-" + month + "-" + day, function (data) {
            console.log("received json");
            return data;
        })
    }

    function setupWindApi(layerControl, date) {
        var handleError = function (err) {
            console.log('handleError...');
            console.log(err);
        };

        // WindJSLeaflet.init({
        //     localMode: false,
        //     map: map,
        //     layerControl: layerControl,
        //     useNearest: true, //nearest to Time
        //     timeISO: date, //=currentTime
        //     nearestDaysLimit: 3,
        //     displayValues: true,
        //     displayOptions: {
        //         displayPosition: 'bottomleft',
        //         displayEmptyString: 'No wind data'
        //     },
        //     overlayName: 'Wind',
        //     pingUrl: 'http://localhost:7000/alive',        // url to check service availability
        //     latestUrl: 'http://localhost:7000/latest',     // url to get latest data with no required params
        //     nearestUrl: 'http://localhost:7000/nearest',
        //     errorCallback: handleError
        // });
    }


    function currentData(layerControl) {
        $.getJSON('https://data.sensor.community/airrohr/v1/filter/area=48.8,9.2,10', function (data) {
            console.log(data);
            let timestamp = data[0].timestamp;
            dustsensors = L.layerGroup({timestamp});
            layerControl.addOverlay(dustsensors, "Feinstaub")
            data.forEach(element => {
                let marker = L.marker([element.location.latitude, element.location.longitude], {time: timestamp}).addTo(dustsensors);
                if (marker !== undefined) {
                    marker.bindPopup("Sensor id: " + element.sensor.id + " timestamp: " + timestamp);
                }
                // dustsensors.add({time: "2013-01-22 12:03:29+01"})
            });
            setupWindApi(layerControl, timestamp);
            // let geojson_now = L.geoJson(array, { time: timestamp });
            // addSlider();
        })
    }

    function pastData(layerControl, time) {
        $.getJSON('http://localhost:3000/dust/all/2020-1-8', function (data) {
            console.log(data);
            let hour = time.hour;
            let minute = time.minute;
            dustsensors = L.layerGroup();
            layerControl.addOverlay(dustsensors, "Feinstaub")
            let number = 140;
            console.log(data[number][hour][minute]);
            console.log(data.length);
            console.log(Object.entries(data));
            for (let obj of Object.entries(data)) {
                if (obj[1][hour] != undefined && obj[1][hour][minute] != undefined) {
                    let element = obj[1][hour][minute];
                    console.log(element);
                    let marker = L.marker([element.lat, element.lon], {time: (time.hour + time.minute)}).addTo(dustsensors);
                    if (marker !== undefined) {
                        marker.bindPopup("Sensor p1: " + element.p1 + " p2: " + element.p2 + "<br/> Time: " + time.hour + ":" + time.minute);
                    }
                }
            }

            //setupWindApi(layerControl, timestamp);
            // let geojson_now = L.geoJson(array, { time: timestamp });
        })
    }

    function loadapi() {
        $.getJSON('https://data.sensor.community/airrohr/v1/filter/area=48.774,9.174,10', function (data) {
            console.log(data);

            data.forEach(element => {
                let marker = L.marker([element.location.latitude, element.location.longitude]).addTo(dustsensors);
                if (marker !== undefined) {
                    marker.bindPopup("Sensor id: " + element.sensor.id + " timestamp: " + element.timestamp);
                }
            });

        })
    }


</script>
<script src="https://unpkg.com/shpjs@latest/dist/shp.js"></script>
</body>

</html>