<!DOCTYPE html>
<html>

<head>
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no"/>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8"/>
    <title>Leaflet</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.3.4/dist/leaflet.css"
          integrity="sha512-puBpdR0798OZvTTbP4A8Ix/l+A4dHDD0DGqYW6RQ+9jxkRFclaxxQb/SJAWZfWAkuyeQUytO7+7N4QKrDh+drA=="
          crossorigin=""/>
    <style>
        html,
        body {
            width: 100%;
            height: 100%;
        }

        body {
            padding: 0;
            margin: 0;
        }

        .legend {
            line-height: 18px;
            color: #555;
            background-color: #ffffff;
            border-style: solid;
            border-color: black;
            border-width: 1px;
        }

        .legend i {
            width: 18px;
            height: 18px;
            float: left;
            margin-right: 8px;
            opacity: 1;
        }

        #map_canvas {
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body onload="initialize()">
<!--<canvas id="myCanvas" width="5000" height="3000" style="border:1px solid #d3d3d3;">
    Your browser does not support the HTML5 canvas tag.</canvas>-->
<div id="map_canvas"></div>

<script src="https://unpkg.com/d3-delaunay@5.1.6/dist/d3-delaunay.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.6.0/proj4-src.js"></script>
<script src="dist/greiner-hormann.js"></script>
<!--<script src="bundle.js"></script>-->
<script src="martinez.min.js"></script>
<!--<script src="https://raw.githubusercontent.com/voidqk/polybooljs/master/dist/polybool.min.js"></script>-->
<script src="https://unpkg.com/leaflet@1.3.4/dist/leaflet.js"
        integrity="sha512-nMMmRyTVoLYqjP9hrbed9S+FzjZHW5gY1TWCHA5ckwXZBadntCNs8kEqAWdrb9O7rxbCaA4lKTIWjDXZxflOcA=="
        crossorigin=""></script>
<script type='text/javascript' src="./proj4leaflet.js"></script>
<script src="leaflet.rotatedMarker.js"></script>
<!--<link rel="stylesheet" href="dist/wind-js-leaflet.css"/>-->
<!--<link rel="stylesheet" href="/demo/demo.css"/>-->
<!--<script src="/dist/wind-js-leaflet.js"></script>-->

<script>
    const geocodeUrl = 'https://nominatim.openstreetmap.org/search?q=';
    const geocodeParams = '&format=json&limit=1';
    let map = null;

    let windIcon = L.icon({
        iconUrl: 'images/wind.png',
        iconSize: [100, 100], // size of the icon
        iconAnchor: [0, 32],
        popupAnchor: [0, -32]
    });

    let windIcon2 = L.icon({
        iconUrl: 'images/wind-direction.png',
        iconSize: [100, 100], // size of the icon
        iconAnchor: [0, 32],
        popupAnchor: [0, -32]
    });

    function DataObject(id, lat, lon, dust) {
        this.id = id;
        this.lat = lat;
        this.lon = lon;
        this.dust = dust;
    }

    let dustsensors;
    let voronoiLayer;
    let stuttgart;

    async function drawVoronoi(dustSensorsPromise, hour, minute) {
        // let canvas = document.getElementById('myCanvas');
        // let context = canvas.getContext("2d");
        // let context = layer;
        // context.fillStyle = "#555555";
        let dustSensors = await dustSensorsPromise;
        console.log(dustSensors);
        let points = [];
        let i = 0;
        for (let key in dustSensors) {
            try {
                let entry = dustSensors[key][hour][minute];
                // console.log("key: " + key + " value: ");
                // console.log(entry);

                // let lon = (entry.lon - 9) * 2500;
                // let lat = (entry.lat - 48.6) * 2500;

                points.push(parseFloat(entry.lon));
                points.push(parseFloat(entry.lat));
                // context.fillRect(lon, lat, 3, 3);
                // console.log("drawing ("+lon +","+lat + ")");
            } catch (err) {
                console.log("sensor had no value for " + hour + ":" + minute);
            }
        }
        // console.log("points");
        // console.log(points);
        let delaunay = new d3.Delaunay(points);

        for (let i = 0; i < delaunay.points.length - 1; i += 2) {
            // console.log("point: " + points[i] + " " + points[i+1]);
            // let marker = L.marker([points[i], points[i+1]]).addTo(voronoi);
            let rectangle = L.rectangle([delaunay.points[i + 1], [delaunay.points[i]], [delaunay.points[i + 1], delaunay.points[i]]], {
                color: "#ff8888",
                weight: 5
            }).addTo(voronoiLayer);
            if (rectangle !== undefined) {
                rectangle.bindPopup("Long: " + points[i] + " Lat: " + points[i + 1]);
            }
        }

        return delaunay;

        // context.fillRect(0,0,150,75);

        // console.log(voronoi.render(context));

        // const points = [[0, 0], [0, 100], [100, 0], [100, 100]];
        // const delaunay = d3.Delaunay.from(points);
        // const voronoi = delaunay.voronoi([0, 0, 960, 500]);

        // let myRender = L.canvas({padding: 0.5});
        // return L.polyline(delaunay.points,{renderer: myRender});

        // return delaunay.render();
        // context.stroke();
    }

    async function getDustSensorsByDate(year, month, day) {
        // $.getJSON('http://localhost:3000/dust/all/2018-7-7', function (data) {
        return $.getJSON('http://localhost:3000/dust/all/' + year + "-" + month + "-" + day, function (data) {
            console.log("received json");
            return data;
        })
    }

    // transforms long lat to lat long for leaflet
    function reverseCoordinates(coordinates) {
        let result = [];
        for (let i = 0; i < coordinates.length; i++) {
            if (Array.isArray(coordinates[i])) {
                result[i] = reverseCoordinates(coordinates[i]);
            } else {
                result[i] = coordinates[i + 1];
                result[i + 1] = coordinates[i];
                return result;
            }
        }
        return result;
    }

    function initialize() {
        var Esri_WorldImagery = L.tileLayer(
            "http://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
            {
                attribution:
                    "Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, " +
                    "AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community",
                minZoom: 12
            }
        );
        // let crs = new L.Proj.CRS('EPSG:25832',
        //     '+proj=utm +zone=32N +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs',
        //     {
        //         resolutions: [
        //             8192, 4096, 2048, 1024, 512, 256, 128
        //         ],
        //         origin: [0, 0]
        //     });

        let otherProjection = "+proj=utm +zone=32 +ellps=GRS80 +units=m +no_defs"; // projection to EPGS 25832
        let lon = 517913.8280646531;
        let lat = 5410477.433508744;
        console.log(lon + "," + lat);

        // proj4 with only 1 projection uses WGS84 as second default
        // proj4 without coordinates returns object, that projects from first to second projection via forward or the other way with inverse
        let converter = proj4(otherProjection);


        let center = L.latLng(48.8, 9.2);
        let zoom = 11;
        map = L.map('map_canvas').setView(center, zoom);
        let osm = new L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'Map data Â© <a href="https://openstreetmap.org">OpenStreetMap</a> contributors',
            minZoom: 12,
            maxZoom: 2,
            renderer: L.svg(),
            // crs: crs
        });
        map.addLayer(Esri_WorldImagery);
        dustsensors = L.layerGroup().addTo(map);
        voronoiSquareLayer = L.layerGroup().addTo(map);
        voronoiLayer = L.layerGroup().addTo(map);
        stuttgart = L.layerGroup().addTo(map);


        let dustSensorsPromise = getDustSensorsByDate(2018, 7, 7);
        let reverseStuttgartPolygon;

        $.getJSON('http://localhost:3000/landkreis', function (data) {
            let coordinates = data.features[0].geometry.coordinates[0]; // coordinates are nested arrays, there is only a single polygon
            for (let i = 0; i < coordinates.length; i++) {
                let point = coordinates[i];
                // console.log("before: " + point.toString());
                coordinates[i] = converter.inverse(point);
                // console.log("after: " + point.toString());
            }
            let worldShadow = [
                [180, -90],
                [180, 90],
                [-180, 90],
                [-180, -90]];

            // console.log(JSON.stringify(coordinates));
            data.features[0].geometry.coordinates[0] = coordinates;
            L.geoJSON(data.features,{
                style: {
                    "color": "#773300",
                    "weight": 5,
                    "fillOpacity": 0.4
                }
            }).addTo(stuttgart);
            // adds large polygon before stuttgart to make it a cutout
            data.features[0].geometry.coordinates.unshift(worldShadow);
            reverseStuttgartPolygon = data.features[0].geometry.coordinates;
            console.log(data);
            // console.log("new data: " + JSON.stringify(data));
            // Makes a stuttgart polygon
            L.geoJSON(data.features, {
                style: {
                    "color": "#222222",
                    "weight": 5,
                    "fillOpacity": 0.8
                }
            }).addTo(map);

            // cutout
            // var shadingPolygon = L.polygon(
            //     [
            //         [
            //             [90, -180],
            //             [90, 180],
            //             [-90, 180],
            //             [-90, -180]],
            //         [
            //             data.features[0].geometry.coordinates[0]
            //         ]
            //     ],
            //     {
            //         "color": "#339933",
            //         "weight": 5,
            //         "opacity": 0.80
            //     }
            // ).addTo(map);
        });
        let delaunayPromise = drawVoronoi(dustSensorsPromise, 0, 50);
        delaunayPromise.then(delaunay => {
            let bounds = [9.036, 48.68972, 9.3164, 48.8697]; // xmin ymin xmax ymax
            let voronoi = delaunay.voronoi(bounds);
            console.log("voronoi polygon:");
            let itr = voronoi.cellPolygons();

            // console.log(reverseStuttgartPolygon);
            let rr = reverseCoordinates(reverseStuttgartPolygon[1]);
            console.log(rr);
            // let a = [[50, 9], [50, 10], [45, 10], [45, 10]];
            // console.log(a);
            // let b = reverseCoordinates(Array.from(a));
            // console.log(b);
            // L.polygon(rr, {
            //     "color": "#888888",
            //     "weight": 5,
            //     "fillOpacity": 0.5
            // }).addTo(map);
            // console.log(reverseStuttgartPolygon);
            let time = 0;
            for (let triangle of itr) {
                console.log("triangle "+ time);
                console.log(triangle);
                // console.log(reverseCoordinates(triangle));
                let reversedTriangle = reverseCoordinates(triangle);
                console.log("reversedTriangle "+ time);
                console.log(reversedTriangle);
                // let cutTriangle = greinerHormann.intersection(reversedTriangle, rr);
                console.log("rr");
                console.log(rr);
                let cutTriangle = martinez.intersection([reversedTriangle], [rr]);
                // // let cutTriangle = triangle
                console.log("cutTriangle "+ time);
                console.log(cutTriangle);

                // setTimeout(function(){
                // let p2 = L.polygon(reversedTriangle, {
                //     color: "#ff3333",
                //     weight: 2,
                //     fillOpacity: 0.5
                // });
                // p2.bindPopup(cutTriangle[0].toString());
                // p2.addTo(voronoiSquareLayer)
                if (cutTriangle != undefined && cutTriangle[0] != undefined) {
                    let p = L.polygon(cutTriangle[0], {
                        color: "#222222",
                        weight: 2,
                        fillOpacity: 0
                    });
                    p.bindPopup(cutTriangle[0].toString());
                    p.addTo(voronoiLayer)
                }
                time++;
                // if (time === 13) {
                //     break;
                // }

                // },time += 50);

            }
            // let coordinates = [];
            // for (let i = 0; i < voronoi.points.length - 1; i += 2) {
            //     coordinates.push([voronoi.points[i + 1], voronoi.points[i]]);
            // }
            // console.log("coordinates");
            // console.log(coordinates);
            // L.polyline(coordinates, {color: 'red'}).addTo(map);

        });

        let background = {Satellite: Esri_WorldImagery, "Clear map": osm};
        let foreground = {
            "Feinstaubsensoren": dustsensors,
            "Voronoi": voronoiLayer,
            "VoronoiSQ": voronoiSquareLayer,
            "Kreis Stuttgart": stuttgart
        };
        let layerControl = L.control.layers(background, foreground, {collapsed: false}).addTo(map);
        let dao = new DataObject(20144, 50.814, 6.590, 0.82);
        /*
                    $.getJSON('http://localhost:3000/wind/4928/2020-1-8-16-20', function (data) {
                        console.log(data);

                    })

                    L.marker([48.73, 9.2], {
                        rotationAngle: 45,
                        icon: windIcon
                    }).addTo(map);
        */
        // loadapi();
        // setInterval(function () {
        //     loadapi()
        // }, 300000);

        var handleError = function (err) {
            console.log('handleError...');
            console.log(err);
        };

        WindJSLeaflet.init({
            localMode: true,
            map: map,
            layerControl: layerControl,
            useNearest: false,
            timeISO: null,
            nearestDaysLimit: 7,
            displayValues: true,
            displayOptions: {
                displayPosition: 'bottomleft',
                displayEmptyString: 'No wind data'
            },
            overlayName: 'wind',
            errorCallback: handleError
        });

    }

    function loadapi() {
        $.getJSON('https://data.sensor.community/airrohr/v1/filter/area=48.774,9.174,10', function (data) {
            console.log(data);

            data.forEach(element => {
                let marker = L.marker([element.location.latitude, element.location.longitude]).addTo(dustsensors);
                if (marker !== undefined) {
                    marker.bindPopup("Sensor id: " + element.sensor.id + " timestamp: " + element.timestamp);
                }
            });

        })
    }


</script>
<script src="https://unpkg.com/shpjs@latest/dist/shp.js"></script>
<script src="https://code.jquery.com/jquery-3.3.1.min.js"
        integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous">
</script>
</body>

</html>